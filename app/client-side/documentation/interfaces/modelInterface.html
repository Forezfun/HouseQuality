<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>house-quality documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">house-quality documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  modelInterface</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/components/scene/scene.component.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Интерфейс для описания размеров модели.</p>

            </p>


        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#height" 
>
                                            height
                                        </a>
                                </li>
                                <li>
                                        <a href="#length" 
>
                                            length
                                        </a>
                                </li>
                                <li>
                                        <a href="#width" 
>
                                            width
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="height"></a>
                                        <span class="name "><b>height</b>
                                            <a href="#height">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>height:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Высота модели</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="length"></a>
                                        <span class="name "><b>length</b>
                                            <a href="#length">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>length:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Длина модели</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="width"></a>
                                        <span class="name "><b>width</b>
                                            <a href="#width">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>width:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Ширина модели</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, AfterViewInit, ElementRef, HostListener, Input, SimpleChanges, Output, EventEmitter, OnChanges, OnDestroy, Renderer2 } from &#x27;@angular/core&#x27;;
import * as THREE from &#x27;three&#x27;;
import { OrbitControls } from &#x27;three/examples/jsm/controls/OrbitControls.js&#x27;;
import { ProjectService, roomData as roomDataPlan } from &#x27;../../services/project.service&#x27;;
import { loadModel } from &#x27;./loaders&#x27;;
import { FurnitureModelControlService } from &#x27;../../services/furniture-model-control.service&#x27;;
import { AccountCookieService } from &#x27;../../services/account-cookie.service&#x27;;
import { FurnitureCardControlService } from &#x27;../../services/furniture-card-control.service&#x27;;
import { ActivatedRoute, Router } from &#x27;@angular/router&#x27;;
import { NotificationService } from &#x27;../../services/notification.service&#x27;;
import { Location, NgIf } from &#x27;@angular/common&#x27;;
import { PlanHouseComponent } from &#x27;../plan-house/plan-house.component&#x27;;

/**
 * Интерфейс для описания размеров модели.
 */
export interface modelInterface {
  /** Ширина модели */
  width: number;
  /** Высота модели */
  height: number;
  /** Длина модели */
  length: number;
}

/**
 * Интерфейс для описания объекта сцены.
 */
export interface objectSceneInterface {
  /** ID объекта */
  objectId: string;
  /** Расстояние по оси X в метрах */
  xMetersDistance: number;
  /** Расстояние по оси Z в метрах */
  zMetersDistance: number;
  /** Угол поворота по оси Y */
  yRotate: number;
}

/**
 * Интерфейс для описания данных загрузки объекта.
 */
interface objectLoadInterface {
  /** Расстояние по оси X */
  xDistance: number;
  /** Расстояние по оси Z */
  zDistance: number;
  /** Угол поворота по оси Y */
  yRotate: number;
}

/**
 * Интерфейс для описания данных комнаты.
 */
interface roomData extends modelInterface {
  /** Массив объектов в комнате */
  objects: objectSceneInterface[];
}

@Component({
  selector: &#x27;app-scene&#x27;,
  standalone: true,
  imports: [NgIf],
  templateUrl: &#x27;./scene.component.html&#x27;,
  styleUrls: [&#x27;./scene.component.scss&#x27;]
})
export class SceneComponent implements AfterViewInit, OnChanges {
  constructor(
    private elementRef: ElementRef,
    private furnitureModelService: FurnitureModelControlService,
    private furnitureCardService: FurnitureCardControlService,
    private accountCookieService: AccountCookieService,
    private projectService: ProjectService,
    private route: ActivatedRoute,
    private notification: NotificationService,
    private location: Location,
    private planHouseComponent: PlanHouseComponent,
    private router: Router
  ) { }


  @Input()
  /** Данные комнаты */
  roomData!: roomDataPlan | undefined;

  @Output()
  /** Событие для сохранения объектов */
  saveObjectsEmitter &#x3D; new EventEmitter&lt;objectSceneInterface[]&gt;();

  /** Рендерер Three.js */
  private renderer!: THREE.WebGLRenderer;

  /** Камера Three.js */
  private camera!: THREE.PerspectiveCamera;

  /** Сцена Three.js */
  private scene!: THREE.Scene;

  /** Контроллеры OrbitControls */
  private controls!: OrbitControls;

  /** ID текущего кадра анимации */
  private animationFrameId: number | null &#x3D; null;

  /** Соотношение размеров холста */
  private canvasRatioOfWindow &#x3D; 1.5;

  /** Пропорции комнаты */
  private roomProportions!: modelInterface;

  /** Луч для определения пересечений */
  private raycaster &#x3D; new THREE.Raycaster();

  /** Координаты мыши */
  private mouse &#x3D; new THREE.Vector2();

  /** Прямоугольная сетка комнаты */
  private rectangleMesh!: THREE.Mesh;

  /** Прямоугольная сетка комнаты */
  private abortConroller: AbortController &#x3D; new AbortController();

  /** Целевой объект для взаимодействия */
  protected targetobject: THREE.Object3D | undefined &#x3D; undefined;

  /** Отображается ли loader */
  protected isShowLoader: boolean &#x3D; false

  /** Были ли изменения roomData */
  public hasBeenChanged: boolean &#x3D; false


  ngAfterViewInit(): void {
    this.initThreeJs();
  }

  ngOnChanges(changes: SimpleChanges): void {
    this.roomData &#x3D; changes[&#x27;roomData&#x27;].currentValue as roomDataPlan

    if (!this.roomData || this.scene &#x3D;&#x3D;&#x3D; undefined) return
    if (changes[&#x27;roomData&#x27;].previousValue !&#x3D;&#x3D; undefined) { this.clearRoom() }

    this.camera.position.set(0, 5, 0)
    this.camera.rotation.set(THREE.MathUtils.degToRad(-90), 0, 0)
    this.roomProportions &#x3D; this.roomData.roomProportions
    this.createRoom();
    this.rectangleMesh.rotation.x &#x3D; THREE.MathUtils.degToRad(-90)

    if (this.getObjectSize(this.rectangleMesh).width &#x3D;&#x3D;&#x3D; 0) return
    if (!this.planHouseComponent.sceneOpenToggle) {
      this.hasBeenChanged &#x3D; true
      return
    }

    this.loadRoom()

    const FURNITURE_ID &#x3D; this.route.snapshot.params[&#x27;furnitureCardId&#x27;]
    if (!FURNITURE_ID || changes[&#x27;roomData&#x27;].previousValue) return

    this.fixPath()

    this.addModel(FURNITURE_ID, true, this.abortConroller)
  }

  private async loadFurnitureModel(fileModel: Blob, furnitureSize: modelInterface, furnitureCardId: string, saveRoom: boolean, moveData?: objectLoadInterface) {
    try {
      const LOAD_OBJECT &#x3D; await loadModel(fileModel)
      if (LOAD_OBJECT instanceof Error) {
        this.notification.setError(&#x27;Модель не поддерживается&#x27;, 5000)
        return
      }
      if (moveData) { this.addObjectToScene(LOAD_OBJECT, furnitureSize, furnitureCardId, moveData) } else { this.addObjectToScene(LOAD_OBJECT, furnitureSize, furnitureCardId) }
      if (saveRoom) { 
        this.saveRoom();
        this.closeLoader()
      }
    } catch (error) {
    }
  }
  private async addModel(furnitureCardId: string, saveRoom: boolean, controller: AbortController, moveData?: objectLoadInterface) {
    const JWT &#x3D; this.accountCookieService.getJwt()
    if (!JWT) return
    try {
      if (saveRoom) this.showLoader()
      const PROPORTIONS &#x3D; (await this.furnitureCardService.GETfurnitureCard(furnitureCardId)).furnitureCard.proportions as modelInterface
      const MODEL &#x3D; await this.furnitureModelService.GETfurnitureModel(JWT, furnitureCardId, controller)
      await this.loadFurnitureModel(MODEL, PROPORTIONS, furnitureCardId, saveRoom, moveData)
    } catch (error) {
      this.notification.setError(&#x27;Ошибка загрузки модели&#x27;, 5000)
      console.log(error)
    }
  }

  private fixPath() {
    const NEW_URL &#x3D; this.location.path().split(&#x27;/&#x27;).slice(0, -1).join(&#x27;/&#x27;)
    this.location.replaceState(NEW_URL)
  }
  /**
   * Инициализация Three.js сцены.
   */
  private initThreeJs(): void {
    this.scene &#x3D; new THREE.Scene();
    this.camera &#x3D; new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const HEMISPHERE_LIGHT &#x3D; new THREE.HemisphereLight(0xaaaaaa, 0x000000, 2);
    this.scene.add(HEMISPHERE_LIGHT);
    this.renderer &#x3D; new THREE.WebGLRenderer({ antialias: true, alpha: false });
    const CANVAS_CONTAINER &#x3D; this.elementRef.nativeElement.querySelector(&#x27;#canvasContainer&#x27;);
    this.camera.position.z &#x3D; 5;
    this.renderer.setSize(window.innerWidth / this.canvasRatioOfWindow, window.innerHeight / this.canvasRatioOfWindow);
    CANVAS_CONTAINER.appendChild(this.renderer.domElement);
    this.animationFrameId &#x3D; requestAnimationFrame(() &#x3D;&gt; this.animate());
    this.renderer.render(this.scene, this.camera);
  }

  /**
   * Анимация сцены.
   */
  private animate(): void {
    this.animationFrameId &#x3D; requestAnimationFrame(() &#x3D;&gt; this.animate());
    this.renderer.render(this.scene, this.camera);
  }

  /**
   * Создает геометрию прямоугольника с закругленными углами.
   * @param width Ширина прямоугольника.
   * @param height Высота прямоугольника.
   * @param radius Радиус закругления.
   * @param segments Количество сегментов.
   * @returns Геометрия прямоугольника.
   */
  private createRoundedRectangleGeometry(width: number, height: number, radius: number, segments: number): THREE.BufferGeometry {
    const SHAPE &#x3D; new THREE.Shape();
    SHAPE.moveTo(-width / 2 + radius, -height / 2);
    SHAPE.lineTo(width / 2 - radius, -height / 2);
    SHAPE.quadraticCurveTo(width / 2, -height / 2, width / 2, -height / 2 + radius);
    SHAPE.lineTo(width / 2, height / 2 - radius);
    SHAPE.quadraticCurveTo(width / 2, height / 2, width / 2 - radius, height / 2);
    SHAPE.lineTo(-width / 2 + radius, height / 2);
    SHAPE.quadraticCurveTo(-width / 2, height / 2, -width / 2, height / 2 - radius);
    SHAPE.lineTo(-width / 2, -height / 2 + radius);
    SHAPE.quadraticCurveTo(-width / 2, -height / 2, -width / 2 + radius, -height / 2);

    const geometry &#x3D; new THREE.ShapeGeometry(SHAPE, segments);

    return geometry;
  }

  /**
   * Создает комнату на сцене.
   */
  private createRoom(): void {
    if (!this.roomData) return
    const ROOM_PROPORTIONS &#x3D; this.roomData.roomProportions
    const RADIUS &#x3D; 0.1
    this.controls &#x3D; new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping &#x3D; true;
    this.controls.dampingFactor &#x3D; 0.15;
    this.controls.enableZoom &#x3D; true;
    this.controls.minDistance &#x3D; 1;
    this.controls.maxDistance &#x3D; 10;
    const paddingPolarAngle &#x3D; 5;
    this.controls.maxPolarAngle &#x3D; THREE.MathUtils.degToRad(90 - paddingPolarAngle);
    this.createRoomShape(ROOM_PROPORTIONS.width, ROOM_PROPORTIONS.length, RADIUS);
    this.rectangleMesh.name &#x3D; &#x27;roomFloorBase&#x27;;
    this.rectangleMesh
  }

  /**
   * Рассчитывает данные для сохранения объекта.
   * @param object Объект сцены.
   * @returns Данные для сохранения объекта.
   */
  private calculateObjectSaveData(object: THREE.Object3D): objectSceneInterface {
    const FLOOR_SIZE &#x3D; this.getObjectSize(this.rectangleMesh)
    const OBJECT_POSITION &#x3D; object.position
    const objectSaveData: objectSceneInterface &#x3D; {
      objectId: (object.userData as any).id,
      xMetersDistance: OBJECT_POSITION.x / FLOOR_SIZE.width * this.roomProportions.width,
      zMetersDistance: OBJECT_POSITION.z / FLOOR_SIZE.length * this.roomProportions.length,
      yRotate: object.rotation.y
    }
    return objectSaveData
  }

  /**
   * Рассчитывает данные для перемещения объекта.
   * @param objectSaveData Данные сохраненного объекта.
   * @returns Данные для перемещения объекта.
   */
  private calculateMoveObjectData(objectSaveData: objectSceneInterface): objectLoadInterface {
    const FLOOR_SIZE &#x3D; this.getObjectSize(this.rectangleMesh)
    return {
      xDistance: objectSaveData.xMetersDistance * FLOOR_SIZE.width / this.roomProportions.width,
      zDistance: objectSaveData.zMetersDistance * FLOOR_SIZE.length / this.roomProportions.length,
      yRotate: objectSaveData.yRotate
    }
  }

  /**
   * Создает форму комнаты.
   * @param widthRatio Соотношение ширины.
   * @param heightRatio Соотношение высоты.
   * @param radius Радиус закругления.
   */
  private createRoomShape(widthRatio: number, heightRatio: number, radius: number): void {
    const CAMERA_FRUSTUM_BOUNDS &#x3D; this.calculateFrustumBounds();
    const SHAPE_RATIO &#x3D; widthRatio / heightRatio;
    let width: number, height: number;

    if (SHAPE_RATIO &lt;&#x3D; 1) {
      width &#x3D; CAMERA_FRUSTUM_BOUNDS.height * SHAPE_RATIO;
      height &#x3D; CAMERA_FRUSTUM_BOUNDS.height;
    } else {
      width &#x3D; CAMERA_FRUSTUM_BOUNDS.width;
      height &#x3D; CAMERA_FRUSTUM_BOUNDS.width / SHAPE_RATIO;
    }
    const SEGMENTS &#x3D; 10;
    const GEOMETRY &#x3D; this.createRoundedRectangleGeometry(width * 0.9, height * 0.9, radius, SEGMENTS);
    const MATERIAL &#x3D; new THREE.MeshBasicMaterial({ color: 3427905 });

    this.rectangleMesh &#x3D; new THREE.Mesh(GEOMETRY, MATERIAL);
    this.scene.add(this.rectangleMesh)
    this.renderer.render(this.scene, this.camera);
    this.rectangleMesh.updateMatrixWorld(true);
  }

  /**
   * Рассчитывает границы камеры.
   * @returns Объект с шириной и высотой камеры.
   */
  private calculateFrustumBounds(): { width: number; height: number } {
    const CAMERA_Y &#x3D; this.camera.position.y;
    const FOV_RAD &#x3D; THREE.MathUtils.degToRad(this.camera.fov);
    const FRUSTUM_HEIGHT &#x3D; 2 * Math.tan(FOV_RAD / 2) * Math.abs(CAMERA_Y);
    const FRUSTUM_WIDTH &#x3D; FRUSTUM_HEIGHT * this.camera.aspect;

    return { width: FRUSTUM_WIDTH, height: FRUSTUM_HEIGHT };
  }

  /**
   * Добавляет объект на сцену.
   * @param object Объект Three.js.
   * @param objectProportions Пропорции объекта.
   * @param furnitureCardId ID карточки мебели.
   * @param moveData Данные для перемещения объекта.
   */
  private addObjectToScene(object: THREE.Object3D, objectProportions: modelInterface, furnitureCardId: string, moveData?: objectLoadInterface): void {
    object.userData &#x3D; { id: furnitureCardId }
    this.scaleImportModel(object, objectProportions);
    this.scene.add(object)
    this.renderer.render(this.scene, this.camera);
    if (!moveData) return
    object.position.set(moveData.xDistance, 0, moveData.zDistance)
    object.rotation.y &#x3D; moveData.yRotate

  }

  /**
   * Получает размеры объекта.
   * @param object Объект Three.js.
   * @returns Размеры объекта.
   */
  private getObjectSize(object: THREE.Object3D): { width: number; height: number; length: number } {
    const BOUNDING_BOX &#x3D; new THREE.Box3().setFromObject(object);
    const SIZE &#x3D; BOUNDING_BOX.getSize(new THREE.Vector3());
    return {
      width: SIZE.x,
      length: SIZE.z,
      height: SIZE.y
    };
  }

  /**
   * Масштабирует импортированную модель.
   * @param object Объект Three.js.
   * @param objectProportions Пропорции объекта.
   */
  private scaleImportModel(object: THREE.Object3D, objectProportions: modelInterface): void {
    let { width, length, height } &#x3D; objectProportions;

    width &#x3D; width / 100;
    length &#x3D; length / 100;
    height &#x3D; height / 100;

    const UPLOAD_OBJECT_SIZE &#x3D; this.getObjectSize(object);

    const SCALE_COEFFICIENT &#x3D; height / UPLOAD_OBJECT_SIZE.height;

    object.scale.set(
      SCALE_COEFFICIENT,
      SCALE_COEFFICIENT,
      SCALE_COEFFICIENT
    );
  }


  /**
   * Загружает комнату с объектами.
   */
  public async loadRoom(): Promise&lt;void&gt; {
    const JWT &#x3D; this.accountCookieService.getJwt()
    if (!JWT || !this.roomData) return
    const roomData: roomData &#x3D; {
      objects: this.roomData.objects,
      ...this.roomData.roomProportions
    }

    this.showLoader()
    for (const object of roomData.objects) {
      await this.addModel(object.objectId, false, this.abortConroller, this.calculateMoveObjectData(object));
    }
    this.closeLoader()
    this.hasBeenChanged &#x3D; false
  }

  private showLoader() {
    this.isShowLoader &#x3D; true
  }
  private closeLoader() {
    this.isShowLoader &#x3D; false
  }
  /**
   * Очищает комнату от объектов.
   */
  private clearRoom(): void {
    for (let i &#x3D; this.scene.children.length - 1; i &gt;&#x3D; 0; i--) {
      const OBJECT &#x3D; this.scene.children[i];
      if (OBJECT.type !&#x3D;&#x3D; &#x27;Scene&#x27; &amp;&amp; OBJECT.type !&#x3D;&#x3D; &#x27;HemisphereLight&#x27;) {
        this.scene.remove(OBJECT);
      }
    }
  }

  /**
   * Обрабатывает изменение размера окна.
   * @param event Событие изменения размера.
   */
  @HostListener(&#x27;window:resize&#x27;, [&#x27;$event&#x27;])
  private onResize(event: Event): void {
    this.renderer.setSize(window.innerWidth / this.canvasRatioOfWindow, window.innerHeight / this.canvasRatioOfWindow);
    this.camera.aspect &#x3D; window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.render(this.scene, this.camera);
  }

  /**
   * Обрабатывает клик мыши.
   * @param event Событие клика.
   */
  @HostListener(&#x27;click&#x27;, [&#x27;$event&#x27;])
  private onMouseClick(event: MouseEvent): void {
    if (this.targetobject) {
      this.targetobject &#x3D; undefined;
      return;
    }
    const RECT &#x3D; (event.target as HTMLCanvasElement).getBoundingClientRect();
    const X &#x3D; (event.clientX - RECT.left) / RECT.width * 2 - 1;
    const Y &#x3D; -(event.clientY - RECT.top) / RECT.height * 2 + 1;

    this.mouse.x &#x3D; X;
    this.mouse.y &#x3D; Y;
    this.raycaster.setFromCamera(this.mouse, this.camera);

    const INTERSECTIONS &#x3D; this.raycaster.intersectObjects(this.scene.children);

    const FOUND_INTERSECTION &#x3D; INTERSECTIONS.find(intersect &#x3D;&gt; {
      return intersect.object.name !&#x3D;&#x3D; &#x27;roomFloorBase&#x27; &amp;&amp; intersect.object.type !&#x3D;&#x3D; &#x27;Scene&#x27; &amp;&amp; intersect.object.type !&#x3D;&#x3D; &#x27;HemisphereLight&#x27;
    })?.object
    if (!FOUND_INTERSECTION) return
    this.targetobject &#x3D; FOUND_INTERSECTION.parent ? FOUND_INTERSECTION.parent : FOUND_INTERSECTION
  }

  /**
   * Поворачивает целевой объект.
   * @param event Событие нажатия клавиши.
   */
  @HostListener(&#x27;window:keydown&#x27;, [&#x27;$event&#x27;])
  private rotateTargetObject(event: KeyboardEvent): void {
    if (!this.targetobject) return
    let rotateAngle &#x3D; -0.05

    switch (event.key) {
      case &#x27;q&#x27;:
      case &#x27;й&#x27;:
        this.targetobject.rotation.y -&#x3D; rotateAngle
        break
      case &#x27;e&#x27;:
      case &#x27;у&#x27;:
        this.targetobject.rotation.y +&#x3D; rotateAngle
    }
  }

  /**
   * Обрабатывает перемещение мыши.
   * @param event Событие перемещения мыши.
   */
  @HostListener(&#x27;mousemove&#x27;, [&#x27;$event&#x27;])
  private onMousemove(event: MouseEvent): void {
    if (!this.targetobject) return;

    const RECT &#x3D; (event.target as HTMLCanvasElement).getBoundingClientRect();
    const X &#x3D; (event.clientX - RECT.left) / RECT.width * 2 - 1;
    const Y &#x3D; -(event.clientY - RECT.top) / RECT.height * 2 + 1;

    this.mouse.x &#x3D; X;
    this.mouse.y &#x3D; Y;
    this.raycaster.setFromCamera(this.mouse, this.camera);

    const INTERSECTIONS &#x3D; this.raycaster.intersectObject(this.rectangleMesh);
    if (INTERSECTIONS.length &#x3D;&#x3D;&#x3D; 0) return;

    const INTERSECTIONS_X &#x3D; INTERSECTIONS[0].point.x;
    const INTERSECTION_Z &#x3D; INTERSECTIONS[0].point.z;
    const RECTANGLE_MESH_SIZE &#x3D; this.getObjectSize(this.rectangleMesh);
    const objectSize &#x3D; this.getObjectSize(this.targetobject);

    const minX &#x3D; -RECTANGLE_MESH_SIZE.width / 2 + objectSize.width / 2;
    const maxX &#x3D; RECTANGLE_MESH_SIZE.width / 2 - objectSize.width / 2;

    let newXObjectPosition &#x3D; INTERSECTIONS_X;
    if (newXObjectPosition &lt; minX) {
      newXObjectPosition &#x3D; minX;
    } else if (newXObjectPosition &gt; maxX) {
      newXObjectPosition &#x3D; maxX;
    }

    const MIN_Z &#x3D; -RECTANGLE_MESH_SIZE.length / 2 + objectSize.length / 2;
    const MAX_Z &#x3D; RECTANGLE_MESH_SIZE.length / 2 - objectSize.length / 2;

    let newZObjectPosition &#x3D; INTERSECTION_Z;
    if (newZObjectPosition &lt; MIN_Z) {
      newZObjectPosition &#x3D; MIN_Z;
    } else if (newZObjectPosition &gt; MAX_Z) {
      newZObjectPosition &#x3D; MAX_Z;
    }

    this.targetobject.position.set(newXObjectPosition, 0, newZObjectPosition);
  }

  /**
   * Генерирует отчет по комнате.
   */
  protected abortLoadRoom() {
    this.abortConroller.abort()
    this.abortConroller &#x3D; new AbortController()

    this.planHouseComponent.sceneOpenToggle &#x3D; false
    this.planHouseComponent.closeViewRoom()

    const PLAN_ID &#x3D; this.route.snapshot.params[&#x27;planId&#x27;]
    this.router.navigateByUrl(&#x27;/plan/&#x27; + PLAN_ID)
  }

  /**
   * Генерирует отчет по комнате.
   */
  protected async getReport(): Promise&lt;void&gt; {
    const JWT &#x3D; this.accountCookieService.getJwt()
    if (!JWT || !this.roomData?._id) return

    const oldCameraPosition &#x3D; this.camera.position.clone();
    const oldCameraRotation &#x3D; this.camera.rotation.clone();

    this.camera.position.set(0, 7, 0)
    this.camera.rotation.set(THREE.MathUtils.degToRad(-90), 0, 0)
    this.renderer.render(this.scene, this.camera);
    const imageDataURL &#x3D; this.renderer.domElement.toDataURL(&#x27;image/png&#x27;)
    const imageDataResponse &#x3D; await fetch(imageDataURL)

    this.camera.position.copy(oldCameraPosition);
    this.camera.rotation.copy(oldCameraRotation);

    if (!imageDataResponse.ok) {
      this.notification.setError(&#x27;Ошибка при рендере&#x27;, 5000)
    }
    const imageDataBlob &#x3D; await imageDataResponse.blob()

    this.projectService.GETgetReportOfRoom(JWT, this.roomData?._id, imageDataBlob)
  }

  /**
   * Удаляет выбранную модель.
   */
  protected deleteModel(): void {
    if (!this.targetobject) return
    this.scene.remove(this.targetobject)
    this.saveRoom()
  }

  /**
   * Сохраняет текущее состояние комнаты.
   */
  public saveRoom(): void {
    if (!this.roomData) return
    const OBJECTS_SCENE_ARRAY &#x3D; this.scene.children.filter(object &#x3D;&gt; {
      if (
        object.name !&#x3D;&#x3D; &#x27;roomFloorBase&#x27; &amp;&amp;
        object.type !&#x3D;&#x3D; &#x27;Scene&#x27; &amp;&amp;
        object.type !&#x3D;&#x3D; &#x27;HemisphereLight&#x27;
      ) {
        return true;
      }
      return false;
    })
      .map(object &#x3D;&gt; {
        return this.calculateObjectSaveData(object)
      })
    const ROOM_OBJECTS_DATA &#x3D; OBJECTS_SCENE_ARRAY
    this.roomData.objects &#x3D; OBJECTS_SCENE_ARRAY
    this.saveObjectsEmitter.emit(ROOM_OBJECTS_DATA)
  }
}</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'modelInterface.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
